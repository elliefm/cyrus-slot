#!/usr/bin/env perl

use warnings;
use strict;

use Cwd;
use Data::Dumper;
use File::Find;
use File::Path;
use IPC::System::Simple qw(run);
use List::MoreUtils qw(uniq);
use POSIX ();

sub usage;
sub slots_from_fs;
sub slots_from_string;
sub become_cyrus;

my $SLOT_PATH = '/cyrus/slot';
my $SLOT_DEFAULTS = "$SLOT_PATH/defaults";

my %CMD_REFS = (
    'init' => \&cmd_init,
    'force-init' => \&cmd_init,

    'configure' => \&cmd_configure,
    'build' => \&cmd_build,
    'check' => \&cmd_check,
    'install' => \&cmd_install,
    
    'fullbuild' => \&cmd_fullbuild,

    'start' => \&cmd_start,
    'stop' => \&cmd_stop,
);

my @saved_argv = @ARGV;

# check for valid slots
my @slots = slots_from_string(shift @ARGV);
exit usage if not scalar @slots;

# check for valid commands
my @commands = @ARGV;
exit usage if not scalar @commands;

my @bad_commands = grep {
    not exists $CMD_REFS{$_};
} @commands;

if (@bad_commands) {
    print STDERR 'error: unrecognised command';
    print STDERR 's' if scalar @bad_commands > 1;
    print STDERR ': ', join(', ', @bad_commands);
    print STDERR "\n";

    exit usage;
}

# become cyrus user
become_cyrus($0, @saved_argv);

# check that slot path exists and is valid
die "not a directory: '$SLOT_PATH'\n" if not -d $SLOT_PATH;
die "directory not readable: '$SLOT_PATH'\n" if not -r $SLOT_PATH;
die "directory not writeable: '$SLOT_PATH'\n" if not -w $SLOT_PATH;
die "directory not executable: '$SLOT_PATH'\n" if not -x $SLOT_PATH;
die "directory not owned by cyrus: '$SLOT_PATH'\n" if not -o $SLOT_PATH;

# run commands
my $g_current_slot;

foreach my $slot (@slots) {
    $g_current_slot = $slot;
    foreach my $command (@commands) {
	my $force = $command =~ m/^force-/;

	eval {
	    $CMD_REFS{$command}->($command, $slot, $force);
	};

	if ($@) {
	    print STDERR "error: $command slot $slot: $@\n";
	}
    }
}

exit 0;

#############################################################

sub usage {
    my ($code) = @_;
    $code = $code || 1;

    print STDERR << "JHLBGK";
usage: $0 slots command [command ...]

JHLBGK

    return $code;
}

sub slots_from_fs {
    opendir my $dh, $SLOT_PATH or die "$SLOT_PATH: $!";

    my @slots = grep { -d "$SLOT_PATH/$_" and m/^\d+$/ } readdir $dh;

    closedir $dh;

    return sort @slots;
}

sub slots_from_string {
    my ($slot_str) = @_;

    return slots_from_fs if $slot_str eq '-a';

    return if $slot_str !~ m/^[\d,-]+$/;

    my @ranges = split /\,/, $slot_str;
    return if not scalar @ranges;

    my @slots;

    foreach my $range (@ranges) {
	my ($start, $end, $junk) = split /-/, $range;

	if (defined $junk) {
	    print STDERR "invalid range: $range\n";
	    return;
	}
	elsif (not $start) {
	    print STDERR "invalid range: $range\n";
	    return;
	}
	elsif (not $end) {
	    push @slots, $start;
	}
	else {
	    if ($start < $end) {
		push @slots, $start .. $end;
	    }
	    else {
		print STDERR "invalid range: $range\n";
		return;
	    }
	}
    }

    return sort uniq @slots;
}

sub become_cyrus {
    my ($zero, @args) = @_;

    my $cyrus = 'cyrus';
    my $pw = getpwnam $cyrus or die "no user named '$cyrus'\n";

    my $uid = POSIX::getuid();

    return if ($uid == $pw); # already cyrus user

    if ($uid == 0) {
        setgid($pw->gid)
            or die "cannot setgid to group $pw->gid: $!";
        setuid($pw->uid)
            or die "cannot setuid to group $pw->uid: $!";
    }
    else {
        my @cmd = ( 'sudo', '-u', $cyrus, $zero, @args );
        exec {'sudo'} @cmd;
	die "sudo -u $cyrus failed: $?";
    }
}

sub install_defaults_cb {
    # skip the entry for the SLOT_DEFAULTS directory itself
    return if $File::Find::name eq $SLOT_DEFAULTS;

    if (-d $File::Find::name) {
	my $dir = substr $File::Find::name, 1 + length $SLOT_DEFAULTS;
	$dir = "$SLOT_PATH/$g_current_slot/$dir";

	if (not -d $dir and not mkdir $dir, 0770) {
	    die "$dir: $!";
	}
    }
    else {
	my $file = substr $File::Find::name, 1 + length $SLOT_DEFAULTS;
	$file = "$SLOT_PATH/$g_current_slot/$file";

	open my $in, '<', $File::Find::name or die "$File::Find::name: $!";
	open my $out, '>', $file or die "$file: $!";

	while (<$in>) {
	    s{$SLOT_DEFAULTS/}{$SLOT_PATH/$g_current_slot/}g;
	    print $out $_;
	}

	close $out;
	close $in;
    }
}

sub newer_file {
    my @files = @_;

    my $newest_mtime = 0;
    my $newest_file;

    foreach my $file (@files) {
	next if not -e $file;

	my $mtime = (stat($file))[9];

	if ($mtime > $newest_mtime) {
	    $newest_mtime = $mtime;
	    $newest_file = $file;
	}
    }

    return $newest_file;
}

sub require_slot {
    my ($slot) = @_;

    # check that the slot exists
    if (not -d "$SLOT_PATH/$slot") {
	die "slot not initialised\n";
    }
}

sub require_slot_config {
    my ($slot) = @_;

    # check that source dir is configured for the correct slot
    if (newer_file(".slot", "Makefile", "configure") ne ".slot") {
	# missing or stale .slot file
	die "not configured for this slot\n";
    }

    my $dot_slot = do {
	local $/ = undef;
	open my $f, '<', '.slot' or die ".slot: $!";
	<$f>;
    };
    chomp $dot_slot;

    if ($dot_slot ne $slot) {
	# wrong .slot file
	die "configured for wrong slot ($dot_slot)\n";
    }
}

sub masterpidfile {
    my ($slot) = @_;

    return "$SLOT_PATH/$slot/var/run/cyrus-master.pid";
}

sub find_binary {
    my ($slot, $name) = @_;

    foreach (qw( bin sbin libexec libexec/cyrus-imapd lib cyrus/bin )) {
        my $dir = "$SLOT_PATH/$slot/usr/cyrus/$_";

        if (opendir my $dh, $dir) {
            if (grep { $_ eq $name } readdir $dh) {
                closedir $dh;
                return "$dir/$name";
            }

            closedir $dh;
        }
    }

    die "couldn't find binary: $name\n";
}

############################################

sub cmd_init {
    my ($command, $slot, $force) = @_;

    if (-d "$SLOT_PATH/$slot") {
	if (not $force) {
	    die "already initialised\n";
	}
    }
    elsif (not mkdir "$SLOT_PATH/$slot", 0770) {
	die "mkdir failed: $!";
    }

    if (-d "$SLOT_DEFAULTS") {
	find(\&install_defaults_cb, $SLOT_DEFAULTS);
    }
}

sub cmd_configure {
    my ($command, $slot, $force) = @_;

    # sanity check
    if (getcwd !~ m/cyrus-imapd$/
	or not -e 'configure.ac'
	or not -e 'Makefile.am'
    ) {
	die "current directory doesn't look like a cyrus source tree\n";
    }
    
    # if configure doesn't exist or is older than configure.ac, autoreconf
    if ("configure.ac" eq newer_file "configure", "configure.ac") {
	print STDERR "configure doesn't exist or is stale, rebuilding\n";
	run qw( autoreconf -i -s );
    }

    # run configure
    my $cflags = '-g -O0 -Wall -Wextra -Werror';
    my @configure_args = qw(
	--enable-silent-rules
	--enable-coverage
	--enable-http
	--enable-unit-tests
	--enable-replication
	--with-openssl=yes
	--enable-nntp
	--enable-murder
	--enable-idled
    );

    run "./configure",
	"CFLAGS=$cflags",
	"--prefix=$SLOT_PATH/$slot/usr/cyrus",
	"--sysconfdir=$SLOT_PATH/$slot/etc",
	@configure_args;

    # update .slot file
    open my $f, '>', '.slot';
    print $f "$slot\n";
    close $f;
}

sub cmd_build {
    my ($command, $slot, $force) = @_;

    require_slot_config($slot);
    run qw( make lex-fix );
    run qw( make -j 16 );
}

sub cmd_check {
    my ($command, $slot, $force) = @_;

    require_slot_config($slot);
    run qw( make check );
}

sub cmd_install {
    my ($command, $slot, $force) = @_;

    require_slot($slot);
    require_slot_config($slot);
    run qw( make install );
}

sub cmd_fullbuild {
    my ($command, $slot, $force) = @_;

    # make configure.ac look newer than anything else
    utime(undef, undef, "configure.ac");

    cmd_configure($command, $slot, $force);
    cmd_build($command, $slot, $force);
    cmd_check($command, $slot, $force);
}

sub cmd_start {
    my ($command, $slot, $force) = @_;

    require_slot($slot);

    my $masterpidfile = masterpidfile $slot;

    if (-e $masterpidfile) {
	my $pid = do {
	    local $/ = undef;
	    open my $fh, '<', $masterpidfile or die "$masterpidfile: $!";
	    <$fh>;
	};
	chomp $pid;

	die "pid file exists ($pid). already running?\n";
    }

    my $master = find_binary($slot, 'master');

    print "sudo $master -p $masterpidfile &\n";
}

sub cmd_stop {
    my ($command, $slot, $force) = @_;

    require_slot($slot);

    my $masterpidfile = masterpidfile $slot;

    if (not -e $masterpidfile) {
	die "not running\n";
    }

    my $pid = do {
	local $/ = undef;
	open my $fh, '<', $masterpidfile or die "$masterpidfile: $!";
	<$fh>;
    };

    chomp $pid;

    die "invalid pid file: $masterpidfile\n" if not $pid or $pid < 0;

    print STDERR "trying nice shutdown...\n";

    kill 'QUIT', $pid;
    foreach my $sec (0..10) {
	if (kill 0, $pid) {
	    print STDERR "still alive after $sec seconds...\n";
	    sleep 1;
	}
	else {
	    last;
	}
    }
    if (kill 0, $pid) {
	print STDERR "killing hard...\n";
	kill 'TERM', $pid;
    }

    if (kill 0, $pid) {
	die "unable to kill $pid even with sigterm??";
    }

    print STDERR "done\n";

    unlink $masterpidfile or die "unlink $masterpidfile: $!";
}
