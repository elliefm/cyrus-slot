#!/usr/bin/env perl

use warnings;
use strict;

use Cwd;
use File::Find;
use File::Path;
use IPC::System::Simple qw(run);
use List::MoreUtils qw(uniq);
use POSIX ();

sub usage;
sub slots_from_string;
sub become_cyrus;

my $SLOT_PATH = '/cyrus/slot';
my $SLOT_DEFAULTS = "$SLOT_PATH/defaults";

my %CMD_REFS = (
    'init' => \&cmd_init,
    'force-init' => \&cmd_init,

    'configure' => \&cmd_configure,
    'build' => \&cmd_build,
    'check' => \&cmd_check,
    'install' => \&cmd_install,
);

my @saved_argv = @ARGV;

# check for valid slots
my @slots = slots_from_string(shift @ARGV);
exit usage if not scalar @slots;

# check for valid commands
my @commands = @ARGV;
exit usage if not scalar @commands;

my @bad_commands = grep {
    not exists $CMD_REFS{$_};
} @commands;

if (@bad_commands) {
    print STDERR 'error: unrecognised command';
    print STDERR 's' if scalar @bad_commands > 1;
    print STDERR ': ', join(', ', @bad_commands);
    print STDERR "\n";

    exit usage;
}

# become cyrus user
become_cyrus($0, @saved_argv);

# check that slot path exists and is valid
die "not a directory: '$SLOT_PATH'" if not -d $SLOT_PATH;
die "directory not readable: '$SLOT_PATH'" if not -r $SLOT_PATH;
die "directory not writeable: '$SLOT_PATH'" if not -w $SLOT_PATH;
die "directory not executable: '$SLOT_PATH'" if not -x $SLOT_PATH;
die "directory not owned by cyrus: '$SLOT_PATH'" if not -o $SLOT_PATH;

# run commands
my $g_current_slot;

foreach my $slot (@slots) {
    $g_current_slot = $slot;
    foreach my $command (@commands) {
	my $force = $command =~ m/^force-/;

	eval {
	    $CMD_REFS{$command}->($command, $slot, $force);
	};

	if ($@) {
	    print STDERR "error: $command slot $slot: $@\n";
	}
    }
}

exit 0;

#############################################################

sub usage {
    my ($code) = @_;
    $code = $code || 1;

    print STDERR << "JHLBGK";
usage: $0 slots command [command ...]

JHLBGK

    return $code;
}

sub slots_from_string {
    my ($slot_str) = @_;

    return if $slot_str !~ m/^[\d,-]+$/;

    my @ranges = split /\,/, $slot_str;
    return if not scalar @ranges;

    my @slots;

    foreach my $range (@ranges) {
	my ($start, $end, $junk) = split /-/, $range;

	if (defined $junk) {
	    print STDERR "invalid range: $range\n";
	    return;
	}
	elsif (not $start) {
	    print STDERR "invalid range: $range\n";
	    return;
	}
	elsif (not $end) {
	    push @slots, $start;
	}
	else {
	    if ($start < $end) {
		push @slots, $start .. $end;
	    }
	    else {
		print STDERR "invalid range: $range\n";
		return;
	    }
	}
    }

    return sort uniq @slots;
}

sub become_cyrus {
    my ($zero, @args) = @_;

    my $cyrus = 'cyrus';
    my $pw = getpwnam $cyrus or die "no user named '$cyrus'";

    my $uid = POSIX::getuid();

    return if ($uid == $pw); # already cyrus user

    if ($uid == 0) {
        setgid($pw->gid)
            or die "cannot setgid to group $pw->gid: $!";
        setuid($pw->uid)
            or die "cannot setuid to group $pw->uid: $!";
    }
    else {
        my @cmd = ( 'sudo', '-u', $cyrus, $zero, @args );
        exec {'sudo'} @cmd;
	die "sudo -u $cyrus failed: $?";
    }
}

sub install_defaults_cb {
    # skip the entry for the SLOT_DEFAULTS directory itself
    return if $File::Find::name eq $SLOT_DEFAULTS;

    if (-d $File::Find::name) {
	my $dir = substr $File::Find::name, 1 + length $SLOT_DEFAULTS;
	$dir = "$SLOT_PATH/$g_current_slot/$dir";

	if (not -d $dir and not mkdir $dir, 0770) {
	    die "$dir: $!";
	}
    }
    else {
	my $file = substr $File::Find::name, 1 + length $SLOT_DEFAULTS;
	$file = "$SLOT_PATH/$g_current_slot/$file";

	open my $in, '<', $File::Find::name or die "$File::Find::name: $!";
	open my $out, '>', $file or die "$file: $!";

	while (<$in>) {
	    s/%SLOT_PATH%/$SLOT_PATH/g;
	    s/%SLOT%/$g_current_slot/g;
	    print $out $_;
	}

	close $out;
	close $in;
    }
}

sub newer_file {
    my @files = @_;

    my $newest_mtime = 0;
    my $newest_file;

    foreach my $file (@files) {
	next if not -e $file;

	my $mtime = (stat($file))[9];

	if ($mtime > $newest_mtime) {
	    $newest_mtime = $mtime;
	    $newest_file = $file;
	}
    }

    return $newest_file;
}

sub require_slot {
    my ($slot) = @_;

    # check that the slot exists
    if (not -d "$SLOT_PATH/$slot") {
	die "slot not initialised\n";
    }
}

sub require_slot_config {
    my ($slot) = @_;

    # check that source dir is configured for the correct slot
    if (newer_file(".slot", "Makefile", "configure") ne ".slot") {
	# missing or stale .slot file
	die "not configured for this slot\n";
    }

    my $dot_slot = do {
	local $/ = undef;
	open my $f, '<', '.slot' or die ".slot: $!";
	<$f>;
    };
    chomp $dot_slot;

    if ($dot_slot ne $slot) {
	# wrong .slot file
	die "configured for wrong slot ($dot_slot)\n";
    }
}

############################################

sub cmd_init {
    my ($command, $slot, $force) = @_;

    if (-d "$SLOT_PATH/$slot") {
	if (not $force) {
	    die "already initialised";
	}
    }
    elsif (not mkdir "$SLOT_PATH/$slot", 0770) {
	die "mkdir failed: $!";
    }

    if (-d "$SLOT_DEFAULTS") {
	find(\&install_defaults_cb, $SLOT_DEFAULTS);
    }
}

sub cmd_configure {
    my ($command, $slot, $force) = @_;

    # sanity check
    if (getcwd !~ m/cyrus-imapd$/
	or not -e 'configure.ac'
	or not -e 'Makefile.am'
    ) {
	die "current directory doesn't look like a cyrus source tree";
    }
    
    # if configure doesn't exist or is older than configure.ac, autoreconf
    if ("configure.ac" eq newer_file "configure", "configure.ac") {
	print STDERR "configure doesn't exist or is stale, rebuilding\n";
	run qw( autoreconf -i -s );
    }

    # run configure
    my $cflags = '-g -O0 -Wall -Wextra -Werror';
    my @configure_args = qw(
	--enable-silent-rules
	--enable-coverage
	--enable-http
	--enable-unit-tests
	--enable-replication
	--with-openssl=yes
	--enable-nntp
	--enable-murder
	--enable-idled
    );

    run "./configure",
	"CFLAGS=$cflags",
	"--prefix=$SLOT_PATH/$slot/usr/cyrus",
	"--sysconfdir=$SLOT_PATH/$slot/etc",
	@configure_args;

    # update .slot file
    open my $f, '>', '.slot';
    print $f "$slot\n";
    close $f;
}

sub cmd_build {
    my ($command, $slot, $force) = @_;

    require_slot_config($slot);
    run qw( make lex-fix );
    run qw( make -j 16 );
}

sub cmd_check {
    my ($command, $slot, $force) = @_;

    require_slot_config($slot);
    run qw( make check );
}

sub cmd_install {
    my ($command, $slot, $force) = @_;

    require_slot($slot);
    require_slot_config($slot);
    run qw( make install );
}
